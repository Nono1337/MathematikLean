{"name": "DHBW Lean Game", "version": "1.1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "DHBW Lean Game-1.1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": -1, "objects": [{"type": "tactic", "content": "3", "name": "assume", "sideBar": true}, {"type": "tactic", "content": "4", "name": "unfold", "sideBar": true}, {"type": "tactic", "content": "5", "name": "use", "sideBar": true}, {"type": "tactic", "content": "6", "name": "rcases", "sideBar": true}, {"type": "tactic", "content": "7", "name": "cases", "sideBar": true}, {"type": "tactic", "content": "8", "name": "induction", "sideBar": true}, {"type": "tactic", "content": "9", "name": "hint, suggest,", "sideBar": true}, {"type": "tactic", "content": "10", "name": "sorry", "sideBar": true}, {"type": "tactic", "content": "11", "name": "exact", "sideBar": true}, {"type": "tactic", "content": "12", "name": "refine", "sideBar": true}, {"type": "tactic", "content": "13", "name": "apply", "sideBar": true}, {"type": "tactic", "content": "14", "name": "simp, dsimp", "sideBar": true}, {"type": "tactic", "content": "15", "name": "rw", "sideBar": true}, {"type": "tactic", "content": "16", "name": "refl", "sideBar": true}, {"type": "tactic", "content": "17", "name": "tauto, tauto!,", "sideBar": true}, {"type": "tactic", "content": "18", "name": "arith, linarith,", "sideBar": true}, {"type": "tactic", "content": "19", "name": "norm_num,", "sideBar": true}, {"type": "tactic", "content": "20", "name": ".mp, .mpr", "sideBar": true}, {"type": "tactic", "content": "21", "name": ".symm", "sideBar": true}, {"type": "text", "content": "22"}]}]}, {"name": "23", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "axiom", "content": "24", "name": "Eine Funktion ist injektive, wenn es zu jedem Element y aus der Zielmenge Y H\u00d6CHSTEN ein (oder gar kein) Element x der Ausgangsmenge X gibt", "sideBar": true}, {"type": "axiom", "content": "25", "name": "Eine Funktion ist surjektiv, wenn es zu jedem Element y aus der Zielmenge Y MINDESTENS ein Element x der Ausgangsmenge X gibt", "sideBar": true}, {"type": "axiom", "content": "26", "name": "Eine Funktion ist bijektive, wenn sie sowohl injektiv als auch surjektiv ist. F\u00fcr ALLE Elemente y aus der Zielmenge Y gibt es GENAU EIN Element x aus der Ausgangsmenge X", "sideBar": true}, {"type": "text", "content": "27"}, {"type": "text", "content": "28"}, {"type": "lean", "content": "29", "hidden": true}, {"type": "lean", "content": "30", "hidden": true}, {"type": "hint", "content": "31", "title": "32"}, {"type": "lemma", "text": "33", "lean": "lemma bij_inj {X Y : Type*} (f : X \u2192 Y) (f_bijective: is_bijective f) : is_injective f :=\n", "sideBar": true, "firstProofLineNumber": 64, "lastProofLineNumber": 64, "textBefore": "/- Axiom : Eine Funktion ist injektive, wenn es zu jedem Element y aus der Zielmenge Y H\u00d6CHSTEN ein (oder gar kein) Element x der Ausgangsmenge X gibt\nis_injective: \u2200 x : X, \u2200 x' : X,\nf(x) = f(x') \u2192 x = x'\n-/\n\n/- Axiom : Eine Funktion ist surjektiv, wenn es zu jedem Element y aus der Zielmenge Y MINDESTENS ein Element x der Ausgangsmenge X gibt\nis_surjective: \u2200 y : Y, \u2203 x : X, f(x) = y\n-/\n\n/- Axiom : Eine Funktion ist bijektive, wenn sie sowohl injektiv als auch surjektiv ist. F\u00fcr ALLE Elemente y aus der Zielmenge Y gibt es GENAU EIN Element x aus der Ausgangsmenge X\nis_bijective: is_injective f \u2227 is_surjective f\n-/\n\n/-\n# Level 1 : Injektivit\u00e4t, Surjektivit\u00e4t und Bijektivit\u00e4t\n-/\n\n\n/-\nWir m\u00f6chten mit einer einfachen \u00dcbung beginnen, um den Einstieg und die Handhabung mit Lean zu erm\u00f6glichen.\nAnhand von den Eigenschaften injektiver, surjektiver und bijektiver Funktion m\u00f6chten wir das Themengebiet genauer beleuchten und nebenbei grundlegende Beweistechniken in Lean genauer kennenlernen. \nZus\u00e4tzlich zu den Bereits kennengelernten Taktiken links sind nun auch Axiome zu finden. Diese Axiome erl\u00e4utern die Definition der Eigenschaften.\nSchauen Sie sich zun\u00e4chst die jeweiligen Definitionen an.\n\nNachdem wir jetzt die Definitionen kennengelernt haben, veranschaulichen wir uns mal die Eigenschaften anhand eines Beispiels.\nWir betrachten die Projektion:\n```\nX = {1; 2; 3}; Y = {1; 2; 3}\nf : X \u2192 Y\n1 \u2192 1\n2 \u2192 1\n3 \u2192 2\n```\nDiese Abbildung ist nicht injektiv, f(1) = 1 = f(2) und nicht surjektiv (auf 3 wird nicht abgebildet).\n\nWir k\u00f6nnen unser neu gewonnenes Wissen nun anwenden, um zu zeigen, dass eine Funktion injektiv ist, sollte sie bijektiv sein.\nDer folgende Beweis ben\u00f6tigt nur eine Zeile Code.\n**Das , am Zeilenende nicht vergessen**\n-/\n\nnamespace jection -- hide\n-- begin hide\ndef is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\n\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\n\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n-- end hide\n\n/- Hint : Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.\nZum Beweisen m\u00fcssen wir uns einfach die Definition von Bijektivit\u00e4t anschauen und die Elimierungseigenschaft der Und-Klausel anwenden.\n-/\n\n/- Lemma\nFalls f bijektiv ist, dann ist f auch injektiv.\n-/\nlemma bij_inj {X Y : Type*} (f : X \u2192 Y) (f_bijective: is_bijective f) : is_injective f :=\nbegin\n", "proof": "    apply and.elim_left f_bijective,", "proof_hint": "sorry", "textAfter": "\nend\n    \nend jection -- hide", "height": 1, "editorText": "sorry", "lineOffset": 63, "name": "bij_inj", "statement": "{X Y : Type*} (f : X \u2192 Y) (f_bijective: is_bijective f) : is_injective f"}, {"type": "lean", "content": "34", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "35"}, {"type": "text", "content": "36"}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lean", "content": "38", "hidden": true}, {"type": "hint", "content": "39", "title": "40"}, {"type": "lemma", "text": "41", "lean": "lemma bij_surj {X Y : Type*} (f : X \u2192 Y) (f_bijective: is_bijective f) : is_surjective f :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 34, "textBefore": "/-\n# Level 2 : Bijektivit\u00e4t und Surjektivit\u00e4t\n-/\n\n\n/-\nNun m\u00f6chten wir analog beweisen, dass eine Funktion surjektiv ist, falls sie bijektiv ist.\n-/\n\nnamespace jection -- hide\n-- begin hide\ndef is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\n\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\n\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n-- end hide\n\n/- Hint : Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.\nZum Beweisen m\u00fcssen wir uns einfach die Definition von Bijektivit\u00e4t anschauen und die Elimierungseigenschaft der Und-Klausel beachten.\nDieses Mal m\u00fcssen wir die rechte Seite eliminieren.\n-/\n\n/- Lemma\nFalls f bijektiv ist, dann ist f auch injektiv.\n-/\nlemma bij_surj {X Y : Type*} (f : X \u2192 Y) (f_bijective: is_bijective f) : is_surjective f :=\nbegin\n", "proof": "  apply and.elim_right f_bijective,", "proof_hint": "sorry", "textAfter": "\nend\n\nend jection -- hide", "height": 1, "editorText": "sorry", "lineOffset": 33, "name": "bij_surj", "statement": "{X Y : Type*} (f : X \u2192 Y) (f_bijective: is_bijective f) : is_surjective f"}, {"type": "lean", "content": "42", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "43"}, {"type": "text", "content": "44"}, {"type": "lean", "content": "45", "hidden": true}, {"type": "lean", "content": "46", "hidden": true}, {"type": "hint", "content": "47", "title": "48"}, {"type": "lemma", "text": "49", "lean": "lemma surj_inj_bij {X Y : Type*} (f : X \u2192 Y) (f_surjective: is_surjective f) (f_injective: is_injective f) : is_bijective f :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 34, "textBefore": "/-\n# Level 3 : Injektiv\u00e4t und Surjektivit\u00e4t\n-/\n\n\n/-\nZum Abschluss zeigen wir nochmal, dass eine Funktion bijektiv ist, falls sie surjektiv und injektiv ist, indem wir die Und-Formel wieder richtig zusammengesetzen. \n-/\n\nnamespace jection -- hide\n-- begin hide\ndef is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\n\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\n\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n-- end hide\n\n/- Hint : Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.\nZum Beweisen m\u00fcssen wir uns einfach die Definition von Bijektivit\u00e4t anschauen und die Und-Klausel beachten.\n(and.intro)\n-/\n\n/- Lemma\nFalls f surjektiv und injektiv ist, dann ist f auch bijektiv.\n-/\nlemma surj_inj_bij {X Y : Type*} (f : X \u2192 Y) (f_surjective: is_surjective f) (f_injective: is_injective f) : is_bijective f :=\nbegin\n", "proof": "  apply and.intro f_injective f_surjective,", "proof_hint": "sorry", "textAfter": "\nend\n\nend jection\n -- hide", "height": 1, "editorText": "sorry", "lineOffset": 33, "name": "surj_inj_bij", "statement": "{X Y : Type*} (f : X \u2192 Y) (f_surjective: is_surjective f) (f_injective: is_injective f) : is_bijective f"}, {"type": "lean", "content": "50", "hidden": false}, {"type": "lean", "content": "51", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "text", "content": "52"}, {"type": "text", "content": "53"}, {"type": "lean", "content": "54", "hidden": true}, {"type": "lean", "content": "55", "hidden": true}, {"type": "hint", "content": "56", "title": "57"}, {"type": "lemma", "text": "58", "lean": "lemma inj_comp_injfirst {X Y Z : Type*} (f : X \u2192 Y) (g : Y \u2192 Z) (gf_injective : is_injective (g \u2218 f)) : is_injective f :=\n", "sideBar": true, "firstProofLineNumber": 53, "lastProofLineNumber": 64, "textBefore": "/-\n# Level 4 : Injektive Komposition\n-/\n\n\n/-\nIn folgendem betrachten wir die Komposition von zwei Abbildungen/Funktionen f und g\nWir haben 3 Mengen X, Y und Z mit x \u03b5 X, y \u03b5 Y und z \u03b5 Z\n$\\operatorname{f}(x)=y$ und $\\operatorname{g}(y)=z$\n\nWir k\u00f6nnen die Verkettung der Funktionen also als $\\operatorname{g}(f(x))=z$ oder als g \u2218 f schreiben\n\nIn Lean werden diese zwei Schreibarten durch *function.comp* abgedeckt: (f \u2218 g) x = f (g x)\n\nWir m\u00f6chten nun beweisen, dass sofern die Komposition g \u2218 f injektiv ist, dann ist f auch alleine injektiv.\nHierf\u00fcr sollten wir uns die Definition der Injektivit\u00e4t nochmals genauer anschauen. Wir versuchen anschlie\u00dfend die \u2200 Behauptungen zu beweisen, indem wir annehmen (assume), dass es zwei Elemente x und x' aus der Menge X, f\u00fcr die gilt, dass f(x) = f(x') ist.\n\n-/\n\nnamespace jection -- hide\n-- begin hide\ndef is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\n\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\n\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n-- end hide\n\n/- Hint : Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.\nNach unseren Annahmen sollte sich das Ziel des Beweises zu x = x' \u00e4ndern. Diese Behauptung k\u00f6nnen wir beweisen, indem wir \u201egf_injective\u201c verwenden (apply) und dann schrittweise die Funktion umschreiben (rw).\n```\n  assume x : X,\n  assume x' : X,\n  assume f_xx' : f x = f x',\n\n  apply gf_injective,\n\n  show (g \u2218 f) x = (g \u2218 f) x', from\n  calc (g \u2218 f) x = g (f x) : \n```\n-/\n\n/- Lemma\nFalls die Komposition g \u2218 f injektiv ist, dann ist f auch alleine injektiv.\n-/\nlemma inj_comp_injfirst {X Y Z : Type*} (f : X \u2192 Y) (g : Y \u2192 Z) (gf_injective : is_injective (g \u2218 f)) : is_injective f :=\nbegin\n", "proof": "  assume x : X,\n  assume x' : X,\n  assume f_xx' : f x = f x',\n\n  have gf_xx' : (g \u2218 f) x = (g \u2218 f) x', from\n  calc (g \u2218 f) x = g (f x) : by rw function.comp_app\n  ... = g (f x') : by rw f_xx'\n  ... = (g \u2218 f) x' : by rw function.comp_app,\n  \n  apply gf_injective,\n  rw gf_xx',\n  --refl,", "proof_hint": "sorry", "textAfter": "\nend\n    \nend jection -- hide", "height": 12, "editorText": "sorry", "lineOffset": 52, "name": "inj_comp_injfirst", "statement": "{X Y Z : Type*} (f : X \u2192 Y) (g : Y \u2192 Z) (gf_injective : is_injective (g \u2218 f)) : is_injective f"}, {"type": "lean", "content": "59", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "60", "hidden": true}, {"type": "text", "content": "61"}, {"type": "text", "content": "62"}, {"type": "lean", "content": "63", "hidden": true}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "hint", "content": "66", "title": "67"}, {"type": "lemma", "text": "68", "lean": "lemma surj_comp_surjsecond {X Y Z : Type*} (f : X \u2192 Y) (g : Y \u2192 Z) (gf_surjective : is_surjective (g \u2218 f)) : is_surjective g :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 71, "textBefore": "import tactic -- hide\n\n/-\n# Level 5 : Surjektive Komposition\n-/\n\n\n/-\nWir betrachten nun erneut die Komposition von zwei Abbildungen/Funktionen f und g\nWir haben 3 Mengen X, Y und Z mit x \u03b5 X, y \u03b5 Y und z \u03b5 Z\n$\\operatorname{f}(x)=y$ und $\\operatorname{g}(y)=z$\n\nWir k\u00f6nnen die Verkettung der Funktionen erneut also als $\\operatorname{g}(f(x))=z$ oder als g \u2218 f schreiben (*function.comp*)\n\nWir m\u00f6chten nun beweisen, dass sofern die Komposition g \u2218 f surjektiv ist, dann ist g auch alleine surjektiv.\nEntsprechend sollten wir uns dieses mal die Definition der Surjektivit\u00e4t nochmals genauer anschauen. Wir versuchen anschlie\u00dfend die \u2200 Behauptungen zu beweisen, indem wir annehmen (assume), dass f\u00fcr jedes Element aus der Zielmenge, z \u03b5 Z, gilt, dass es ein Element aus der Startmenge gibt, sodass gilt: $\\operatorname{g}(f(x)) = z\n\nDiesesmal wird sogar der Anfang vorgegeben, da die Verwendung der ***rcases*** Taktik ein tieferes Verst\u00e4ndnis von Lean erfordert.\n```\n  assume z : Z,\n  have ex_x : \u2203 x : X, (g \u2218 f) x = z := gf_surjective z,\n  rcases ex_x with \u27e8 x : X, gf_x_z\u27e9,\n```\nAls Gegenleistung sollten Sie zuerst versuchen die vorgegebenen Schritte, durch Klicken auf die einzelnen Zeilen und anschlie\u00dfendem analysieren, wie sich jeweils das Ziel des Beweises \u00e4ndert, zu verstehen und anschlie\u00dfend d\u00fcrfen Sie selbst\u00e4ndig den Beweis vervollst\u00e4ndigen.\n-/\n\nopen classical -- hide\n\n\nnamespace jection -- hide\n-- begin hide\ndef is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\n\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\n\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n-- end hide\n\n/- Hint : Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.\nNach unseren Annahmen ist zu beweisen, dass es ein Element aus der Menge y gibt, das durch die Funktion g auf unser z abbildet.\nWir k\u00f6nnen beweisen, dass es ein Element aus X gibt, welches \u00fcber die Komposition auf z abbildet.\n***rcases*** wird verwendet, um ***ex_x*** destrukturieren.\nWir k\u00f6nnen nun $\\operatorname{f}(x)=y$ verwenden, um den Beweis zu vollenden.\n```\nlet y : Y := f x,\nuse y,\n\nshow g y = z, from\n```\n-/\n\n/- Lemma\nFalls die Komposition g \u2218 f surjektiv ist, dann ist g auch alleine surjektiv.\n-/\nlemma surj_comp_surjsecond {X Y Z : Type*} (f : X \u2192 Y) (g : Y \u2192 Z) (gf_surjective : is_surjective (g \u2218 f)) : is_surjective g :=\nbegin\n", "proof": "  assume z : Z,\n  have ex_x : \u2203 x : X, (g \u2218 f) x = z := gf_surjective z,\n  rcases ex_x with \u27e8 x : X, gf_x_z\u27e9,\n  let y : Y := f x,\n  use y,\n\n  show g y = z, from\n  calc g y = g (f x) : by simp\n  ... = (g \u2218 f) x : by rw function.comp_app\n  ... = z : by rw gf_x_z,", "proof_hint": "sorry", "textAfter": "\nend\n    \nend jection -- hide", "height": 10, "editorText": "sorry", "lineOffset": 61, "name": "surj_comp_surjsecond", "statement": "{X Y Z : Type*} (f : X \u2192 Y) (g : Y \u2192 Z) (gf_surjective : is_surjective (g \u2218 f)) : is_surjective g"}, {"type": "lean", "content": "69", "hidden": true}]}], "parents": [0]}], "texts": [["DHBW Lean Game", "# The DHBW Lean Game, version 1.0.0.\n\n# What is this game?\n\nThis game allows you to solve mathematical problems with the lean programming language.\n\n# Credits\n\nThe DHBW Lean Game was made by students of DHBW Mannheim and is based on the Topology Game https://github.com/mmasdeu/topologygame\n\nLean is a computer theorem prover being developed at Microsoft Research.\n\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "dictionary", "## Summary\nintroduces an identifer, as preparation for a proof of\nan all-statement or an implication\n", "## Summary\nunfolds a definition\n", "## Summary\nprove an existential statement from an example\n", "## Summary\nrecursive pattern matching;\nextracts, e.g., a witness from an existential term\n", "## Summary\nproof by case distinction\n", "## Summary\nproof by induction (not only over natural numbers)\n", "library_search\n## Summary\ntactics that search for ways to make progress in the\nproof\n", "## Summary\npretends to be a proof (useful for developing the overall\nstructure of a proof)\nor a value of the given type (usually dangerous)\n", "## Summary\nsolves the current goal by giving an exact proof term\n", "## Summary\nlike exact, but can contain wildcards/holes _\nthat may lead to new goals\n", "## Summary\ntries to match the conclusion of the argument to the\ncurrent goal; might create new goals\n", "## Summary\ntries to use lemmas and hypotheses to simplify the\ncurrent goal;\ndsimp is like simp, using only definitional equalities\n", "## Summary\napplies the argument as a rewrite rule to the current\ngoal\n", "## Summary\ntries to resolve the goal through de\fnitional equality\n", "finish\n## Summary\nFinishing tactics, trying to solve the goal completely\nusing basic logic, definitional equalities, etc.\n", "omega, ring\n## Summary\ntactics that handle arithmetic equalities and inequalities\nof various types; particularly convenient in combination\nwith calc\n", "norm_cast\n## Summary\nnormalise expressions in various ways\n", "## Summary\nextracts implications from left to right (or right to\nleft, respectively) from equivalences\n", "## Summary\nconverts equalities x = y into y = x.\n", "this is a placeholder\n", "bijectivity", "is_injective: \u2200 x : X, \u2200 x' : X,\nf(x) = f(x') \u2192 x = x'\n", "is_surjective: \u2200 y : Y, \u2203 x : X, f(x) = y\n", "is_bijective: is_injective f \u2227 is_surjective f\n", "# Level 1 : Injektivit\u00e4t, Surjektivit\u00e4t und Bijektivit\u00e4t\n", "Wir m\u00f6chten mit einer einfachen \u00dcbung beginnen, um den Einstieg und die Handhabung mit Lean zu erm\u00f6glichen.\nAnhand von den Eigenschaften injektiver, surjektiver und bijektiver Funktion m\u00f6chten wir das Themengebiet genauer beleuchten und nebenbei grundlegende Beweistechniken in Lean genauer kennenlernen. \nZus\u00e4tzlich zu den Bereits kennengelernten Taktiken links sind nun auch Axiome zu finden. Diese Axiome erl\u00e4utern die Definition der Eigenschaften.\nSchauen Sie sich zun\u00e4chst die jeweiligen Definitionen an.\n\nNachdem wir jetzt die Definitionen kennengelernt haben, veranschaulichen wir uns mal die Eigenschaften anhand eines Beispiels.\nWir betrachten die Projektion:\n```\nX = {1; 2; 3}; Y = {1; 2; 3}\nf : X \u2192 Y\n1 \u2192 1\n2 \u2192 1\n3 \u2192 2\n```\nDiese Abbildung ist nicht injektiv, f(1) = 1 = f(2) und nicht surjektiv (auf 3 wird nicht abgebildet).\n\nWir k\u00f6nnen unser neu gewonnenes Wissen nun anwenden, um zu zeigen, dass eine Funktion injektiv ist, sollte sie bijektiv sein.\nDer folgende Beweis ben\u00f6tigt nur eine Zeile Code.\n**Das , am Zeilenende nicht vergessen**\n", "namespace jection -- hide\n", "def is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n", "Zum Beweisen m\u00fcssen wir uns einfach die Definition von Bijektivit\u00e4t anschauen und die Elimierungseigenschaft der Und-Klausel anwenden.\n", "Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.", "Falls f bijektiv ist, dann ist f auch injektiv.\n", "end jection -- hide", "# Level 2 : Bijektivit\u00e4t und Surjektivit\u00e4t\n", "Nun m\u00f6chten wir analog beweisen, dass eine Funktion surjektiv ist, falls sie bijektiv ist.\n", "namespace jection -- hide\n", "def is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n", "Zum Beweisen m\u00fcssen wir uns einfach die Definition von Bijektivit\u00e4t anschauen und die Elimierungseigenschaft der Und-Klausel beachten.\nDieses Mal m\u00fcssen wir die rechte Seite eliminieren.\n", "Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.", "Falls f bijektiv ist, dann ist f auch injektiv.\n", "end jection -- hide", "# Level 3 : Injektiv\u00e4t und Surjektivit\u00e4t\n", "Zum Abschluss zeigen wir nochmal, dass eine Funktion bijektiv ist, falls sie surjektiv und injektiv ist, indem wir die Und-Formel wieder richtig zusammengesetzen. \n", "namespace jection -- hide\n", "def is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n", "Zum Beweisen m\u00fcssen wir uns einfach die Definition von Bijektivit\u00e4t anschauen und die Und-Klausel beachten.\n(and.intro)\n", "Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.", "Falls f surjektiv und injektiv ist, dann ist f auch bijektiv.\n", "end jection\n", " -- hide", "# Level 4 : Injektive Komposition\n", "In folgendem betrachten wir die Komposition von zwei Abbildungen/Funktionen f und g\nWir haben 3 Mengen X, Y und Z mit x \u03b5 X, y \u03b5 Y und z \u03b5 Z\n$\\operatorname{f}(x)=y$ und $\\operatorname{g}(y)=z$\n\nWir k\u00f6nnen die Verkettung der Funktionen also als $\\operatorname{g}(f(x))=z$ oder als g \u2218 f schreiben\n\nIn Lean werden diese zwei Schreibarten durch *function.comp* abgedeckt: (f \u2218 g) x = f (g x)\n\nWir m\u00f6chten nun beweisen, dass sofern die Komposition g \u2218 f injektiv ist, dann ist f auch alleine injektiv.\nHierf\u00fcr sollten wir uns die Definition der Injektivit\u00e4t nochmals genauer anschauen. Wir versuchen anschlie\u00dfend die \u2200 Behauptungen zu beweisen, indem wir annehmen (assume), dass es zwei Elemente x und x' aus der Menge X, f\u00fcr die gilt, dass f(x) = f(x') ist.\n\n", "namespace jection -- hide\n", "def is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n", "Nach unseren Annahmen sollte sich das Ziel des Beweises zu x = x' \u00e4ndern. Diese Behauptung k\u00f6nnen wir beweisen, indem wir \u201egf_injective\u201c verwenden (apply) und dann schrittweise die Funktion umschreiben (rw).\n```\n  assume x : X,\n  assume x' : X,\n  assume f_xx' : f x = f x',\n\n  apply gf_injective,\n\n  show (g \u2218 f) x = (g \u2218 f) x', from\n  calc (g \u2218 f) x = g (f x) : \n```\n", "Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.", "Falls die Komposition g \u2218 f injektiv ist, dann ist f auch alleine injektiv.\n", "end jection -- hide", "import tactic -- hide\n", "# Level 5 : Surjektive Komposition\n", "Wir betrachten nun erneut die Komposition von zwei Abbildungen/Funktionen f und g\nWir haben 3 Mengen X, Y und Z mit x \u03b5 X, y \u03b5 Y und z \u03b5 Z\n$\\operatorname{f}(x)=y$ und $\\operatorname{g}(y)=z$\n\nWir k\u00f6nnen die Verkettung der Funktionen erneut also als $\\operatorname{g}(f(x))=z$ oder als g \u2218 f schreiben (*function.comp*)\n\nWir m\u00f6chten nun beweisen, dass sofern die Komposition g \u2218 f surjektiv ist, dann ist g auch alleine surjektiv.\nEntsprechend sollten wir uns dieses mal die Definition der Surjektivit\u00e4t nochmals genauer anschauen. Wir versuchen anschlie\u00dfend die \u2200 Behauptungen zu beweisen, indem wir annehmen (assume), dass f\u00fcr jedes Element aus der Zielmenge, z \u03b5 Z, gilt, dass es ein Element aus der Startmenge gibt, sodass gilt: $\\operatorname{g}(f(x)) = z\n\nDiesesmal wird sogar der Anfang vorgegeben, da die Verwendung der ***rcases*** Taktik ein tieferes Verst\u00e4ndnis von Lean erfordert.\n```\n  assume z : Z,\n  have ex_x : \u2203 x : X, (g \u2218 f) x = z := gf_surjective z,\n  rcases ex_x with \u27e8 x : X, gf_x_z\u27e9,\n```\nAls Gegenleistung sollten Sie zuerst versuchen die vorgegebenen Schritte, durch Klicken auf die einzelnen Zeilen und anschlie\u00dfendem analysieren, wie sich jeweils das Ziel des Beweises \u00e4ndert, zu verstehen und anschlie\u00dfend d\u00fcrfen Sie selbst\u00e4ndig den Beweis vervollst\u00e4ndigen.\n", "open classical -- hide\n", "namespace jection -- hide\n", "def is_injective {X Y: Type*} (f : X \u2192 Y) \n:= \u2200 x : X, \u2200 x' : X,\nf x = f x' \u2192 x = x'\ndef is_surjective {X Y: Type*} (f : X \u2192 Y)\n:= \u2200 y : Y, \u2203 x : X,\nf x = y\ndef is_bijective {X Y: Type*} (f : X \u2192 Y)\n:= is_injective f \u2227 is_surjective f\n", "Nach unseren Annahmen ist zu beweisen, dass es ein Element aus der Menge y gibt, das durch die Funktion g auf unser z abbildet.\nWir k\u00f6nnen beweisen, dass es ein Element aus X gibt, welches \u00fcber die Komposition auf z abbildet.\n***rcases*** wird verwendet, um ***ex_x*** destrukturieren.\nWir k\u00f6nnen nun $\\operatorname{f}(x)=y$ verwenden, um den Beweis zu vollenden.\n```\nlet y : Y := f x,\nuse y,\n\nshow g y = z, from\n```\n", "Falls Sie nicht weiterkommen, hier klicken f\u00fcr einen Hinweis.", "Falls die Komposition g \u2218 f surjektiv ist, dann ist g auch alleine surjektiv.\n", "end jection -- hide"]]}